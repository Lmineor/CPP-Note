#include <iostream>
using namespace std;
//引用.cpp

/*
引用：给变量起别名
语法： 数据类型 & 别名 = 原名
int a = =10;
int &b = a;
b = 20;
cout << a<<endl;  -->a = 20

### 注意事项
1. 引用必须初始化
int a =10;
int &b = a; 正确
int &b; //错误
2. 初始化后不能改变
int a =10;
int c =10;
int &b = a; 正确
int &b = c; //错误

但是可以赋值
b = c; //正确
*/



/*
引用：作函数参数
看例子；
总结： 通过引用参数产生的效果同按地址传递是一样的
*/


/*
引用：作函数返回值
看例子；
总结： 通过引用参数产生的效果同按地址传递是一样的
*/


//1 值传递
void mySwap01(int a, int b){
    int tmp = a;
    a = b;
    b = tmp;
};

// 2 地址传递
void mySwap02(int *a, int *b){
    int tmp = *a;
    *a = *b;
    *b = tmp;
};

// 3 引用传递
void mySwap03(int &a, int &b){
    int tmp = a;
    a = b;
    b = tmp;
};

// 引用作函数的返回值==============================================================
// 1 不要返回局部变量的引用
int & test01(){
    int var1 = 10; // 局部变量存放在四区中的栈区
    return var1;
};
//2、 函数的调用可以作为左值
int & test02()
{
    static int var2 = 20; // 静态变量，存在全局区，全局区上的数据在程序结束后系统释放
    return var2;
};
// 引用作函数的返回值==============================================================

// 引用本质==============================================================
//以用的本质就是一个指针常量，一旦初始化，就不能改变
void func(int & ref){
    ref = 100; // ref是引用，转换为*ref = 100;
}

// 常量引用==============================================================
//使用场景：修饰形参，防止误操作
void showValue(const int &val){
    cout << "val is :" << val <<endl;
}
// 常量引用=============================================================

int main(){
    int a = 10;
    cout << a <<endl; // 10
    int &b = a;

    int c = 20;
    b = 20;
    cout << a <<endl; // 20
    cout << b <<endl; // 20

    //测试函数
    int num1 = 20;
    int num2 = 30;
    mySwap01(num1, num2); // 值传递
    cout << "num1: " << num1 << endl;
    cout << "num2: " << num2 << endl;

    mySwap02(&num1, &num2); // 地址传递
    cout << "num1: " << num1 << endl;
    cout << "num2: " << num2 << endl;

    mySwap03(num1, num2); // 引用传递
    cout << "num1: " << num1 << endl;
    cout << "num2: " << num2 << endl;

    /*
    num1: 20
    num2: 30
    num1: 30
    num2: 20
    num1: 20
    num2: 30
    */


   // 不要返回局部变量的引用
    // int & test01_ref = test01();
    // cout << test01_ref <<endl; // 警告

    // 函数的调用可以作为左值
    int & test02_ref = test02();
    cout << "test02_ref: "<< test02_ref <<endl; //20

    test02() = 100; // 如果函数的返回值是引用，这个函数调用可以作为左值
    cout << "test02_ref: "<< test02_ref <<endl; //20

    // 引用本质==============================================================
    int var3 = 10;

    // 自动转换为 int * const ref = &a ; //指针常量是指针指向不变，也就是说明为什么引用不可更改
    int & ref = a;
    ref =20; //内部发现ref是引用，自动帮我们转换为： *ref  =20;

    // 引用本质==============================================================
    
    // 常量引用==============================================================
    //使用场景：修饰形参，防止误操作
    //int a  = 10;
    // int & ref = 10; // 引用必须引用一块合法的内存空间 // 这个是错误的
    //加上const之后，编译器将代码修改为int tmp = 10; const int & ref = tmp;
    //const int & ref = 10; // 正确 
    // ref = 20; // 加入const之后变成只读，不可修改

    int var4  =100;
    showValue(var4);
    // 常量引用=============================================================

    
    
    return 0;
}